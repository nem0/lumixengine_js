// Generated by meta_js.cpp

#include "editor/asset_browser.h"
#include "gui/gui_system.h"
#include "renderer/editor/scene_view.h"
#include "animation/animation_module.h"
#include "audio/audio_module.h"
#include "engine/core.h"
#include "gui/gui_module.h"
#include "lua/lua_script_system.h"
#include "navigation/navigation_module.h"
#include "physics/physics_module.h"
#include "core/geometry.h"
#include "renderer/model.h"
#include "renderer/render_module.h"
#include "../plugins/jolt/src/jolt_module.h"
#include "../plugins/js/src/js_script_system.h"


namespace Lumix {
	static int property_animator_getEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isPropertyAnimatorEnabled(entity));
		return 1;
	}
	
	static int property_animator_setEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->enablePropertyAnimator(entity, value);
		return 0;
	}
	
	static int property_animator_getLooped(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getPropertyAnimatorLooped(entity));
		return 1;
	}
	
	static int property_animator_setLooped(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setPropertyAnimatorLooped(entity, value);
		return 0;
	}
	
	static int property_animator_getAnimation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getPropertyAnimatorAnimation(entity));
		return 1;
	}
	
	static int property_animator_setAnimation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setPropertyAnimatorAnimation(entity, value);
		return 0;
	}
	
	static int animator_getSource(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAnimatorSource(entity));
		return 1;
	}
	
	static int animator_setSource(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setAnimatorSource(entity, value);
		return 0;
	}
	
	static int animator_getUseRootMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAnimatorUseRootMotion(entity));
		return 1;
	}
	
	static int animator_setUseRootMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setAnimatorUseRootMotion(entity, value);
		return 0;
	}
	
	static int animator_getDefaultSet(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAnimatorDefaultSet(entity));
		return 1;
	}
	
	static int animator_setDefaultSet(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setAnimatorDefaultSet(entity, value);
		return 0;
	}
	
	static int animable_getAnimation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAnimableAnimation(entity));
		return 1;
	}
	
	static int animable_setAnimation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AnimationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setAnimableAnimation(entity, value);
		return 0;
	}
	
	static int ambient_sound_getClip(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AudioModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAmbientSoundClip(entity));
		return 1;
	}
	
	static int ambient_sound_setClip(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AudioModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setAmbientSoundClip(entity, value);
		return 0;
	}
	
	static int ambient_sound_getIs_3D(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AudioModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isAmbientSound3D(entity));
		return 1;
	}
	
	static int ambient_sound_setIs_3D(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<AudioModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setAmbientSound3D(entity, value);
		return 0;
	}
	
	static int gui_rect_getEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isRectEnabled(entity));
		return 1;
	}
	
	static int gui_rect_setEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->enableRect(entity, value);
		return 0;
	}
	
	static int gui_rect_getClip(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectClip(entity));
		return 1;
	}
	
	static int gui_rect_setClip(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setRectClip(entity, value);
		return 0;
	}
	
	static int gui_rect_getLeftPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectLeftPoints(entity));
		return 1;
	}
	
	static int gui_rect_setLeftPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectLeftPoints(entity, value);
		return 0;
	}
	
	static int gui_rect_getLeftRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectLeftRelative(entity));
		return 1;
	}
	
	static int gui_rect_setLeftRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectLeftRelative(entity, value);
		return 0;
	}
	
	static int gui_rect_getRightPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectRightPoints(entity));
		return 1;
	}
	
	static int gui_rect_setRightPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectRightPoints(entity, value);
		return 0;
	}
	
	static int gui_rect_getRightRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectRightRelative(entity));
		return 1;
	}
	
	static int gui_rect_setRightRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectRightRelative(entity, value);
		return 0;
	}
	
	static int gui_rect_getTopPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectTopPoints(entity));
		return 1;
	}
	
	static int gui_rect_setTopPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectTopPoints(entity, value);
		return 0;
	}
	
	static int gui_rect_getTopRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectTopRelative(entity));
		return 1;
	}
	
	static int gui_rect_setTopRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectTopRelative(entity, value);
		return 0;
	}
	
	static int gui_rect_getBottomPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectBottomPoints(entity));
		return 1;
	}
	
	static int gui_rect_setBottomPoints(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectBottomPoints(entity, value);
		return 0;
	}
	
	static int gui_rect_getBottomRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRectBottomRelative(entity));
		return 1;
	}
	
	static int gui_rect_setBottomRelative(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRectBottomRelative(entity, value);
		return 0;
	}
	
	static int gui_button_getHoveredColorRGBA(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getButtonHoveredColorRGBA(entity));
		return 1;
	}
	
	static int gui_button_setHoveredColorRGBA(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec4>(ctx, 3);
		ctx, module->setButtonHoveredColorRGBA(entity, value);
		return 0;
	}
	
	static int gui_button_getHoveredCursor(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getButtonHoveredCursor(entity));
		return 1;
	}
	
	static int gui_button_setHoveredCursor(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (os::CursorType)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setButtonHoveredCursor(entity, value);
		return 0;
	}
	
	static int gui_image_getEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isImageEnabled(entity));
		return 1;
	}
	
	static int gui_image_setEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->enableImage(entity, value);
		return 0;
	}
	
	static int gui_image_getColorRGBA(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getImageColorRGBA(entity));
		return 1;
	}
	
	static int gui_image_setColorRGBA(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec4>(ctx, 3);
		ctx, module->setImageColorRGBA(entity, value);
		return 0;
	}
	
	static int gui_image_getSprite(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getImageSprite(entity));
		return 1;
	}
	
	static int gui_image_setSprite(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setImageSprite(entity, value);
		return 0;
	}
	
	static int gui_text_getFontSize(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTextFontSize(entity));
		return 1;
	}
	
	static int gui_text_setFontSize(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<int>(ctx, 3);
		ctx, module->setTextFontSize(entity, value);
		return 0;
	}
	
	static int gui_text_getColorRGBA(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTextColorRGBA(entity));
		return 1;
	}
	
	static int gui_text_setColorRGBA(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec4>(ctx, 3);
		ctx, module->setTextColorRGBA(entity, value);
		return 0;
	}
	
	static int gui_text_getFontPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTextFontPath(entity));
		return 1;
	}
	
	static int gui_text_setFontPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setTextFontPath(entity, value);
		return 0;
	}
	
	static int gui_text_getHAlign(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getTextHAlign(entity));
		return 1;
	}
	
	static int gui_text_setHAlign(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (TextHAlign)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setTextHAlign(entity, value);
		return 0;
	}
	
	static int gui_text_getVAlign(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getTextVAlign(entity));
		return 1;
	}
	
	static int gui_text_setVAlign(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (TextVAlign)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setTextVAlign(entity, value);
		return 0;
	}
	
	static int gui_text_getText(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getText(entity));
		return 1;
	}
	
	static int gui_text_setText(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<GUIModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<const char*>(ctx, 3);
		ctx, module->setText(entity, value);
		return 0;
	}
	
	static int lua_script_inline_getCode(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<LuaScriptModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getInlineScriptCode(entity));
		return 1;
	}
	
	static int lua_script_inline_setCode(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<LuaScriptModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<const char*>(ctx, 3);
		ctx, module->setInlineScriptCode(entity, value);
		return 0;
	}
	
	static int navmesh_zone_getAutoload(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getZoneAutoload(entity));
		return 1;
	}
	
	static int navmesh_zone_setAutoload(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setZoneAutoload(entity, value);
		return 0;
	}
	
	static int navmesh_zone_getDetailed(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getZoneDetailed(entity));
		return 1;
	}
	
	static int navmesh_zone_setDetailed(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setZoneDetailed(entity, value);
		return 0;
	}
	
	static int navmesh_agent_getRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAgentRadius(entity));
		return 1;
	}
	
	static int navmesh_agent_setRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setAgentRadius(entity, value);
		return 0;
	}
	
	static int navmesh_agent_getHeight(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAgentHeight(entity));
		return 1;
	}
	
	static int navmesh_agent_setHeight(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setAgentHeight(entity, value);
		return 0;
	}
	
	static int navmesh_agent_getMoveEntity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAgentMoveEntity(entity));
		return 1;
	}
	
	static int navmesh_agent_setMoveEntity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setAgentMoveEntity(entity, value);
		return 0;
	}
	
	static int navmesh_agent_getSpeed(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<NavigationModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAgentSpeed(entity));
		return 1;
	}
	
	static int physical_heightfield_getSource(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHeightfieldSource(entity));
		return 1;
	}
	
	static int physical_heightfield_setSource(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setHeightfieldSource(entity, value);
		return 0;
	}
	
	static int physical_heightfield_getXZScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHeightfieldXZScale(entity));
		return 1;
	}
	
	static int physical_heightfield_setXZScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setHeightfieldXZScale(entity, value);
		return 0;
	}
	
	static int physical_heightfield_getYScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHeightfieldYScale(entity));
		return 1;
	}
	
	static int physical_heightfield_setYScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setHeightfieldYScale(entity, value);
		return 0;
	}
	
	static int physical_heightfield_getLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHeightfieldLayer(entity));
		return 1;
	}
	
	static int physical_heightfield_setLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setHeightfieldLayer(entity, value);
		return 0;
	}
	
	static int d6_joint_getXMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getD6JointXMotion(entity));
		return 1;
	}
	
	static int d6_joint_setXMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::D6Motion)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setD6JointXMotion(entity, value);
		return 0;
	}
	
	static int d6_joint_getYMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getD6JointYMotion(entity));
		return 1;
	}
	
	static int d6_joint_setYMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::D6Motion)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setD6JointYMotion(entity, value);
		return 0;
	}
	
	static int d6_joint_getZMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getD6JointZMotion(entity));
		return 1;
	}
	
	static int d6_joint_setZMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::D6Motion)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setD6JointZMotion(entity, value);
		return 0;
	}
	
	static int d6_joint_getSwing1Motion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getD6JointSwing1Motion(entity));
		return 1;
	}
	
	static int d6_joint_setSwing1Motion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::D6Motion)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setD6JointSwing1Motion(entity, value);
		return 0;
	}
	
	static int d6_joint_getSwing2Motion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getD6JointSwing2Motion(entity));
		return 1;
	}
	
	static int d6_joint_setSwing2Motion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::D6Motion)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setD6JointSwing2Motion(entity, value);
		return 0;
	}
	
	static int d6_joint_getTwistMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getD6JointTwistMotion(entity));
		return 1;
	}
	
	static int d6_joint_setTwistMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::D6Motion)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setD6JointTwistMotion(entity, value);
		return 0;
	}
	
	static int d6_joint_getLinearLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointLinearLimit(entity));
		return 1;
	}
	
	static int d6_joint_setLinearLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setD6JointLinearLimit(entity, value);
		return 0;
	}
	
	static int d6_joint_getTwistLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointTwistLimit(entity));
		return 1;
	}
	
	static int d6_joint_setTwistLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setD6JointTwistLimit(entity, value);
		return 0;
	}
	
	static int d6_joint_getSwingLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointSwingLimit(entity));
		return 1;
	}
	
	static int d6_joint_setSwingLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setD6JointSwingLimit(entity, value);
		return 0;
	}
	
	static int d6_joint_getDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointDamping(entity));
		return 1;
	}
	
	static int d6_joint_setDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setD6JointDamping(entity, value);
		return 0;
	}
	
	static int d6_joint_getStiffness(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointStiffness(entity));
		return 1;
	}
	
	static int d6_joint_setStiffness(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setD6JointStiffness(entity, value);
		return 0;
	}
	
	static int d6_joint_getRestitution(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointRestitution(entity));
		return 1;
	}
	
	static int d6_joint_setRestitution(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setD6JointRestitution(entity, value);
		return 0;
	}
	
	static int d6_joint_getConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointConnectedBody(entity));
		return 1;
	}
	
	static int d6_joint_setConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<EntityPtr>(ctx, 3);
		ctx, module->setD6JointConnectedBody(entity, value);
		return 0;
	}
	
	static int d6_joint_getAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointAxisPosition(entity));
		return 1;
	}
	
	static int d6_joint_setAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setD6JointAxisPosition(entity, value);
		return 0;
	}
	
	static int d6_joint_getAxisDirection(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getD6JointAxisDirection(entity));
		return 1;
	}
	
	static int d6_joint_setAxisDirection(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setD6JointAxisDirection(entity, value);
		return 0;
	}
	
	static int distance_joint_getConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDistanceJointConnectedBody(entity));
		return 1;
	}
	
	static int distance_joint_setConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<EntityPtr>(ctx, 3);
		ctx, module->setDistanceJointConnectedBody(entity, value);
		return 0;
	}
	
	static int distance_joint_getAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDistanceJointAxisPosition(entity));
		return 1;
	}
	
	static int distance_joint_setAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setDistanceJointAxisPosition(entity, value);
		return 0;
	}
	
	static int distance_joint_getDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDistanceJointDamping(entity));
		return 1;
	}
	
	static int distance_joint_setDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setDistanceJointDamping(entity, value);
		return 0;
	}
	
	static int distance_joint_getStiffness(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDistanceJointStiffness(entity));
		return 1;
	}
	
	static int distance_joint_setStiffness(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setDistanceJointStiffness(entity, value);
		return 0;
	}
	
	static int distance_joint_getTolerance(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDistanceJointTolerance(entity));
		return 1;
	}
	
	static int distance_joint_setTolerance(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setDistanceJointTolerance(entity, value);
		return 0;
	}
	
	static int distance_joint_getLimits(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDistanceJointLimits(entity));
		return 1;
	}
	
	static int distance_joint_setLimits(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setDistanceJointLimits(entity, value);
		return 0;
	}
	
	static int distance_joint_getLinearForce(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDistanceJointLinearForce(entity));
		return 1;
	}
	
	static int hinge_joint_getConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHingeJointConnectedBody(entity));
		return 1;
	}
	
	static int hinge_joint_setConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<EntityPtr>(ctx, 3);
		ctx, module->setHingeJointConnectedBody(entity, value);
		return 0;
	}
	
	static int hinge_joint_getAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHingeJointAxisPosition(entity));
		return 1;
	}
	
	static int hinge_joint_setAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setHingeJointAxisPosition(entity, value);
		return 0;
	}
	
	static int hinge_joint_getAxisDirection(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHingeJointAxisDirection(entity));
		return 1;
	}
	
	static int hinge_joint_setAxisDirection(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setHingeJointAxisDirection(entity, value);
		return 0;
	}
	
	static int hinge_joint_getDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHingeJointDamping(entity));
		return 1;
	}
	
	static int hinge_joint_setDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setHingeJointDamping(entity, value);
		return 0;
	}
	
	static int hinge_joint_getStiffness(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHingeJointStiffness(entity));
		return 1;
	}
	
	static int hinge_joint_setStiffness(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setHingeJointStiffness(entity, value);
		return 0;
	}
	
	static int hinge_joint_getUseLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHingeJointUseLimit(entity));
		return 1;
	}
	
	static int hinge_joint_setUseLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setHingeJointUseLimit(entity, value);
		return 0;
	}
	
	static int hinge_joint_getLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getHingeJointLimit(entity));
		return 1;
	}
	
	static int hinge_joint_setLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setHingeJointLimit(entity, value);
		return 0;
	}
	
	static int spherical_joint_getConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getSphericalJointConnectedBody(entity));
		return 1;
	}
	
	static int spherical_joint_setConnectedBody(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<EntityPtr>(ctx, 3);
		ctx, module->setSphericalJointConnectedBody(entity, value);
		return 0;
	}
	
	static int spherical_joint_getAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getSphericalJointAxisPosition(entity));
		return 1;
	}
	
	static int spherical_joint_setAxisPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setSphericalJointAxisPosition(entity, value);
		return 0;
	}
	
	static int spherical_joint_getAxisDirection(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getSphericalJointAxisDirection(entity));
		return 1;
	}
	
	static int spherical_joint_setAxisDirection(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setSphericalJointAxisDirection(entity, value);
		return 0;
	}
	
	static int spherical_joint_getUseLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getSphericalJointUseLimit(entity));
		return 1;
	}
	
	static int spherical_joint_setUseLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setSphericalJointUseLimit(entity, value);
		return 0;
	}
	
	static int spherical_joint_getLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getSphericalJointLimit(entity));
		return 1;
	}
	
	static int spherical_joint_setLimit(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setSphericalJointLimit(entity, value);
		return 0;
	}
	
	static int physical_controller_getLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getControllerLayer(entity));
		return 1;
	}
	
	static int physical_controller_setLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setControllerLayer(entity, value);
		return 0;
	}
	
	static int physical_controller_getRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getControllerRadius(entity));
		return 1;
	}
	
	static int physical_controller_setRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setControllerRadius(entity, value);
		return 0;
	}
	
	static int physical_controller_getHeight(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getControllerHeight(entity));
		return 1;
	}
	
	static int physical_controller_setHeight(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setControllerHeight(entity, value);
		return 0;
	}
	
	static int physical_controller_getCustomGravity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getControllerCustomGravity(entity));
		return 1;
	}
	
	static int physical_controller_setCustomGravity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setControllerCustomGravity(entity, value);
		return 0;
	}
	
	static int physical_controller_getCustomGravityAcceleration(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getControllerCustomGravityAcceleration(entity));
		return 1;
	}
	
	static int physical_controller_setCustomGravityAcceleration(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setControllerCustomGravityAcceleration(entity, value);
		return 0;
	}
	
	static int physical_controller_getUseRootMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getControllerUseRootMotion(entity));
		return 1;
	}
	
	static int physical_controller_setUseRootMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setControllerUseRootMotion(entity, value);
		return 0;
	}
	
	static int rigid_actor_getVelocity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getActorVelocity(entity));
		return 1;
	}
	
	static int rigid_actor_getSpeed(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getActorSpeed(entity));
		return 1;
	}
	
	static int rigid_actor_getLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getActorLayer(entity));
		return 1;
	}
	
	static int rigid_actor_setLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setActorLayer(entity, value);
		return 0;
	}
	
	static int rigid_actor_getDynamicType(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getActorDynamicType(entity));
		return 1;
	}
	
	static int rigid_actor_setDynamicType(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::DynamicType)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setActorDynamicType(entity, value);
		return 0;
	}
	
	static int rigid_actor_getIsTrigger(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getActorIsTrigger(entity));
		return 1;
	}
	
	static int rigid_actor_setIsTrigger(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setActorIsTrigger(entity, value);
		return 0;
	}
	
	static int rigid_actor_getMesh(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getActorMesh(entity));
		return 1;
	}
	
	static int rigid_actor_setMesh(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setActorMesh(entity, value);
		return 0;
	}
	
	static int rigid_actor_getMaterial(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getActorMaterial(entity));
		return 1;
	}
	
	static int rigid_actor_setMaterial(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setActorMaterial(entity, value);
		return 0;
	}
	
	static int rigid_actor_getCCD(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getActorCCD(entity));
		return 1;
	}
	
	static int rigid_actor_setCCD(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setActorCCD(entity, value);
		return 0;
	}
	
	static int wheel_getSpringStrength(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelSpringStrength(entity));
		return 1;
	}
	
	static int wheel_setSpringStrength(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelSpringStrength(entity, value);
		return 0;
	}
	
	static int wheel_getSpringMaxCompression(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelSpringMaxCompression(entity));
		return 1;
	}
	
	static int wheel_setSpringMaxCompression(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelSpringMaxCompression(entity, value);
		return 0;
	}
	
	static int wheel_getSpringMaxDroop(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelSpringMaxDroop(entity));
		return 1;
	}
	
	static int wheel_setSpringMaxDroop(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelSpringMaxDroop(entity, value);
		return 0;
	}
	
	static int wheel_getSpringDamperRate(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelSpringDamperRate(entity));
		return 1;
	}
	
	static int wheel_setSpringDamperRate(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelSpringDamperRate(entity, value);
		return 0;
	}
	
	static int wheel_getRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelRadius(entity));
		return 1;
	}
	
	static int wheel_setRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelRadius(entity, value);
		return 0;
	}
	
	static int wheel_getWidth(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelWidth(entity));
		return 1;
	}
	
	static int wheel_setWidth(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelWidth(entity, value);
		return 0;
	}
	
	static int wheel_getMass(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelMass(entity));
		return 1;
	}
	
	static int wheel_setMass(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelMass(entity, value);
		return 0;
	}
	
	static int wheel_getMOI(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelMOI(entity));
		return 1;
	}
	
	static int wheel_setMOI(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setWheelMOI(entity, value);
		return 0;
	}
	
	static int wheel_getSlot(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getWheelSlot(entity));
		return 1;
	}
	
	static int wheel_setSlot(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (PhysicsModule::WheelSlot)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setWheelSlot(entity, value);
		return 0;
	}
	
	static int wheel_getRPM(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getWheelRPM(entity));
		return 1;
	}
	
	static int vehicle_getPeakTorque(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehiclePeakTorque(entity));
		return 1;
	}
	
	static int vehicle_setPeakTorque(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setVehiclePeakTorque(entity, value);
		return 0;
	}
	
	static int vehicle_getMaxRPM(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleMaxRPM(entity));
		return 1;
	}
	
	static int vehicle_setMaxRPM(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setVehicleMaxRPM(entity, value);
		return 0;
	}
	
	static int vehicle_getRPM(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleRPM(entity));
		return 1;
	}
	
	static int vehicle_getCurrentGear(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleCurrentGear(entity));
		return 1;
	}
	
	static int vehicle_getSpeed(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleSpeed(entity));
		return 1;
	}
	
	static int vehicle_getChassis(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleChassis(entity));
		return 1;
	}
	
	static int vehicle_setChassis(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setVehicleChassis(entity, value);
		return 0;
	}
	
	static int vehicle_getMass(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleMass(entity));
		return 1;
	}
	
	static int vehicle_setMass(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setVehicleMass(entity, value);
		return 0;
	}
	
	static int vehicle_getMOIMultiplier(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleMOIMultiplier(entity));
		return 1;
	}
	
	static int vehicle_setMOIMultiplier(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setVehicleMOIMultiplier(entity, value);
		return 0;
	}
	
	static int vehicle_getCenterOfMass(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleCenterOfMass(entity));
		return 1;
	}
	
	static int vehicle_setCenterOfMass(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setVehicleCenterOfMass(entity, value);
		return 0;
	}
	
	static int vehicle_getWheelsLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleWheelsLayer(entity));
		return 1;
	}
	
	static int vehicle_setWheelsLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setVehicleWheelsLayer(entity, value);
		return 0;
	}
	
	static int vehicle_getChassisLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getVehicleChassisLayer(entity));
		return 1;
	}
	
	static int vehicle_setChassisLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setVehicleChassisLayer(entity, value);
		return 0;
	}
	
	static int physical_instanced_cube_getHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getInstancedCubeHalfExtents(entity));
		return 1;
	}
	
	static int physical_instanced_cube_setHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setInstancedCubeHalfExtents(entity, value);
		return 0;
	}
	
	static int physical_instanced_cube_getLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getInstancedCubeLayer(entity));
		return 1;
	}
	
	static int physical_instanced_cube_setLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setInstancedCubeLayer(entity, value);
		return 0;
	}
	
	static int physical_instanced_mesh_getLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getInstancedMeshLayer(entity));
		return 1;
	}
	
	static int physical_instanced_mesh_setLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setInstancedMeshLayer(entity, value);
		return 0;
	}
	
	static int physical_instanced_mesh_getGeomPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getInstancedMeshGeomPath(entity));
		return 1;
	}
	
	static int physical_instanced_mesh_setGeomPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<PhysicsModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setInstancedMeshGeomPath(entity, value);
		return 0;
	}
	
	static int decal_getMaterialPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDecalMaterialPath(entity));
		return 1;
	}
	
	static int decal_setMaterialPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setDecalMaterialPath(entity, value);
		return 0;
	}
	
	static int decal_getHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getDecalHalfExtents(entity));
		return 1;
	}
	
	static int decal_setHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setDecalHalfExtents(entity, value);
		return 0;
	}
	
	static int environment_getCastShadows(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getEnvironmentCastShadows(entity));
		return 1;
	}
	
	static int environment_setCastShadows(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setEnvironmentCastShadows(entity, value);
		return 0;
	}
	
	static int environment_getSkyTexture(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getEnvironmentSkyTexture(entity));
		return 1;
	}
	
	static int environment_setSkyTexture(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setEnvironmentSkyTexture(entity, value);
		return 0;
	}
	
	static int environment_getShadowmapCascades(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getEnvironmentShadowmapCascades(entity));
		return 1;
	}
	
	static int environment_setShadowmapCascades(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec4>(ctx, 3);
		ctx, module->setEnvironmentShadowmapCascades(entity, value);
		return 0;
	}
	
	static int point_light_getRange(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getPointLightRange(entity));
		return 1;
	}
	
	static int point_light_setRange(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setPointLightRange(entity, value);
		return 0;
	}
	
	static int point_light_getCastShadows(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getPointLightCastShadows(entity));
		return 1;
	}
	
	static int point_light_setCastShadows(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setPointLightCastShadows(entity, value);
		return 0;
	}
	
	static int point_light_getDynamic(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getPointLightDynamic(entity));
		return 1;
	}
	
	static int point_light_setDynamic(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setPointLightDynamic(entity, value);
		return 0;
	}
	
	static int reflection_probe_getEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isReflectionProbeEnabled(entity));
		return 1;
	}
	
	static int reflection_probe_setEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->enableReflectionProbe(entity, value);
		return 0;
	}
	
	static int environment_probe_getEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isEnvironmentProbeEnabled(entity));
		return 1;
	}
	
	static int environment_probe_setEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->enableEnvironmentProbe(entity, value);
		return 0;
	}
	
	static int bone_attachment_getParent(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getBoneAttachmentParent(entity));
		return 1;
	}
	
	static int bone_attachment_setParent(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<EntityPtr>(ctx, 3);
		ctx, module->setBoneAttachmentParent(entity, value);
		return 0;
	}
	
	static int bone_attachment_getBone(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getBoneAttachmentBone(entity));
		return 1;
	}
	
	static int bone_attachment_setBone(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<int>(ctx, 3);
		ctx, module->setBoneAttachmentBone(entity, value);
		return 0;
	}
	
	static int bone_attachment_getPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getBoneAttachmentPosition(entity));
		return 1;
	}
	
	static int bone_attachment_setPosition(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setBoneAttachmentPosition(entity, value);
		return 0;
	}
	
	static int bone_attachment_getRotation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getBoneAttachmentRotation(entity));
		return 1;
	}
	
	static int bone_attachment_setRotation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setBoneAttachmentRotation(entity, value);
		return 0;
	}
	
	static int particle_emitter_getPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getParticleEmitterPath(entity));
		return 1;
	}
	
	static int particle_emitter_setPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setParticleEmitterPath(entity, value);
		return 0;
	}
	
	static int particle_emitter_getAutodestroy(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getParticleEmitterAutodestroy(entity));
		return 1;
	}
	
	static int particle_emitter_setAutodestroy(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setParticleEmitterAutodestroy(entity, value);
		return 0;
	}
	
	static int instanced_model_getPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getInstancedModelPath(entity));
		return 1;
	}
	
	static int instanced_model_setPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setInstancedModelPath(entity, value);
		return 0;
	}
	
	static int model_instance_getEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isModelInstanceEnabled(entity));
		return 1;
	}
	
	static int model_instance_setEnabled(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->enableModelInstance(entity, value);
		return 0;
	}
	
	static int model_instance_getPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getModelInstancePath(entity));
		return 1;
	}
	
	static int model_instance_setPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setModelInstancePath(entity, value);
		return 0;
	}
	
	static int curve_decal_getMaterialPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getCurveDecalMaterialPath(entity));
		return 1;
	}
	
	static int curve_decal_setMaterialPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setCurveDecalMaterialPath(entity, value);
		return 0;
	}
	
	static int curve_decal_getHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getCurveDecalHalfExtents(entity));
		return 1;
	}
	
	static int curve_decal_setHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setCurveDecalHalfExtents(entity, value);
		return 0;
	}
	
	static int curve_decal_getUVScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getCurveDecalUVScale(entity));
		return 1;
	}
	
	static int curve_decal_setUVScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setCurveDecalUVScale(entity, value);
		return 0;
	}
	
	static int curve_decal_getBezierP0(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getCurveDecalBezierP0(entity));
		return 1;
	}
	
	static int curve_decal_setBezierP0(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setCurveDecalBezierP0(entity, value);
		return 0;
	}
	
	static int curve_decal_getBezierP2(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getCurveDecalBezierP2(entity));
		return 1;
	}
	
	static int curve_decal_setBezierP2(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec2>(ctx, 3);
		ctx, module->setCurveDecalBezierP2(entity, value);
		return 0;
	}
	
	static int terrain_getSize(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTerrainSize(entity));
		return 1;
	}
	
	static int terrain_getMaterialPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTerrainMaterialPath(entity));
		return 1;
	}
	
	static int terrain_setMaterialPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setTerrainMaterialPath(entity, value);
		return 0;
	}
	
	static int terrain_getXZScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTerrainXZScale(entity));
		return 1;
	}
	
	static int terrain_setXZScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setTerrainXZScale(entity, value);
		return 0;
	}
	
	static int terrain_getTesselation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTerrainTesselation(entity));
		return 1;
	}
	
	static int terrain_setTesselation(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setTerrainTesselation(entity, value);
		return 0;
	}
	
	static int terrain_getBaseGridResolution(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTerrainBaseGridResolution(entity));
		return 1;
	}
	
	static int terrain_setBaseGridResolution(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<u32>(ctx, 3);
		ctx, module->setTerrainBaseGridResolution(entity, value);
		return 0;
	}
	
	static int terrain_getYScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getTerrainYScale(entity));
		return 1;
	}
	
	static int terrain_setYScale(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setTerrainYScale(entity, value);
		return 0;
	}
	
	static int procedural_geom_getMaterial(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getProceduralGeometryMaterial(entity));
		return 1;
	}
	
	static int procedural_geom_setMaterial(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<RenderModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setProceduralGeometryMaterial(entity, value);
		return 0;
	}
	
	static int jolt_mesh_getPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getMeshPath(entity));
		return 1;
	}
	
	static int jolt_mesh_setPath(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Path>(ctx, 3);
		ctx, module->setMeshPath(entity, value);
		return 0;
	}
	
	static int jolt_sphere_getRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getSphereRadius(entity));
		return 1;
	}
	
	static int jolt_sphere_setRadius(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setSphereRadius(entity, value);
		return 0;
	}
	
	static int jolt_box_getHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getBoxHalfExtents(entity));
		return 1;
	}
	
	static int jolt_box_setHalfExtents(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setBoxHalfExtents(entity, value);
		return 0;
	}
	
	static int jolt_body_getSpeed(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getBodySpeed(entity));
		return 1;
	}
	
	static int jolt_body_getActive(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isBodyActive(entity));
		return 1;
	}
	
	static int jolt_body_getDescreteMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->isDiscreteMotion(entity));
		return 1;
	}
	
	static int jolt_body_setDescreteMotion(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<bool>(ctx, 3);
		ctx, module->setDiscreteMotion(entity, value);
		return 0;
	}
	
	static int jolt_body_getFriction(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getFriction(entity));
		return 1;
	}
	
	static int jolt_body_setFriction(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setFriction(entity, value);
		return 0;
	}
	
	static int jolt_body_getRestitution(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getRestitution(entity));
		return 1;
	}
	
	static int jolt_body_setRestitution(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setRestitution(entity, value);
		return 0;
	}
	
	static int jolt_body_getLinearDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getLinearDamping(entity));
		return 1;
	}
	
	static int jolt_body_setLinearDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setLinearDamping(entity, value);
		return 0;
	}
	
	static int jolt_body_getAngularDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAngularDamping(entity));
		return 1;
	}
	
	static int jolt_body_setAngularDamping(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<float>(ctx, 3);
		ctx, module->setAngularDamping(entity, value);
		return 0;
	}
	
	static int jolt_body_getDynamicType(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getDynamicType(entity));
		return 1;
	}
	
	static int jolt_body_setDynamicType(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (JPH::EMotionType)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setDynamicType(entity, value);
		return 0;
	}
	
	static int jolt_body_getLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, (i32)module->getLayer(entity));
		return 1;
	}
	
	static int jolt_body_setLayer(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = (ObjectLayer)JSWrapper::checkArg<i32>(ctx, 3);
		ctx, module->setLayer(entity, value);
		return 0;
	}
	
	static int jolt_body_getLinearVelocity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getLinearVelocity(entity));
		return 1;
	}
	
	static int jolt_body_setLinearVelocity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setLinearVelocity(entity, value);
		return 0;
	}
	
	static int jolt_body_getAngularVelocity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if(!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		JSWrapper::push(ctx, module->getAngularVelocity(entity));
		return 1;
	}
	
	static int jolt_body_setAngularVelocity(duk_context* ctx) {
		duk_push_this(ctx);
		if (duk_is_null_or_undefined(ctx, -1)) {
			duk_eval_error(ctx, "`this` is null or undefined");
		}
		duk_get_prop_string(ctx, -1, "c_module");
		auto* module = JSWrapper::toType<JoltModule*>(ctx, -1);
		if (!module) duk_eval_error(ctx, "getting property on invalid object");
		duk_get_prop_string(ctx, -2, "c_entity");
		EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);
		duk_pop_2(ctx);
		auto value = JSWrapper::checkArg<Vec3>(ctx, 3);
		ctx, module->setAngularVelocity(entity, value);
		return 0;
	}
	
	void registerJSAPI(duk_context* ctx) {
		// property_animator
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "property_animator");
			duk_get_global_string(ctx, "property_animator");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Enabled");
			duk_push_c_function(ctx, &property_animator_getEnabled, 0);
			duk_push_c_function(ctx, &property_animator_setEnabled, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "property_animator");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Looped");
			duk_push_c_function(ctx, &property_animator_getLooped, 0);
			duk_push_c_function(ctx, &property_animator_setLooped, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "property_animator");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Animation");
			duk_push_c_function(ctx, &property_animator_getAnimation, 0);
			duk_push_c_function(ctx, &property_animator_setAnimation, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// animator
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "animator");
			duk_get_global_string(ctx, "animator");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Source");
			duk_push_c_function(ctx, &animator_getSource, 0);
			duk_push_c_function(ctx, &animator_setSource, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "animator");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "UseRootMotion");
			duk_push_c_function(ctx, &animator_getUseRootMotion, 0);
			duk_push_c_function(ctx, &animator_setUseRootMotion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "animator");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "DefaultSet");
			duk_push_c_function(ctx, &animator_getDefaultSet, 0);
			duk_push_c_function(ctx, &animator_setDefaultSet, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// animable
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "animable");
			duk_get_global_string(ctx, "animable");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Animation");
			duk_push_c_function(ctx, &animable_getAnimation, 0);
			duk_push_c_function(ctx, &animable_setAnimation, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// echo_zone
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "echo_zone");
		}
		// chorus_zone
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "chorus_zone");
		}
		// audio_listener
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "audio_listener");
		}
		// ambient_sound
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "ambient_sound");
			duk_get_global_string(ctx, "ambient_sound");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Clip");
			duk_push_c_function(ctx, &ambient_sound_getClip, 0);
			duk_push_c_function(ctx, &ambient_sound_setClip, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "ambient_sound");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Is3D");
			duk_push_c_function(ctx, &ambient_sound_getIs_3D, 0);
			duk_push_c_function(ctx, &ambient_sound_setIs_3D, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// spline
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "spline");
		}
		// signal
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "signal");
		}
		// gui_canvas
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "gui_canvas");
		}
		// gui_render_target
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "gui_render_target");
		}
		// gui_input_field
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "gui_input_field");
		}
		// gui_rect
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "gui_rect");
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Enabled");
			duk_push_c_function(ctx, &gui_rect_getEnabled, 0);
			duk_push_c_function(ctx, &gui_rect_setEnabled, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Clip");
			duk_push_c_function(ctx, &gui_rect_getClip, 0);
			duk_push_c_function(ctx, &gui_rect_setClip, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "LeftPoints");
			duk_push_c_function(ctx, &gui_rect_getLeftPoints, 0);
			duk_push_c_function(ctx, &gui_rect_setLeftPoints, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "LeftRelative");
			duk_push_c_function(ctx, &gui_rect_getLeftRelative, 0);
			duk_push_c_function(ctx, &gui_rect_setLeftRelative, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "RightPoints");
			duk_push_c_function(ctx, &gui_rect_getRightPoints, 0);
			duk_push_c_function(ctx, &gui_rect_setRightPoints, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "RightRelative");
			duk_push_c_function(ctx, &gui_rect_getRightRelative, 0);
			duk_push_c_function(ctx, &gui_rect_setRightRelative, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "TopPoints");
			duk_push_c_function(ctx, &gui_rect_getTopPoints, 0);
			duk_push_c_function(ctx, &gui_rect_setTopPoints, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "TopRelative");
			duk_push_c_function(ctx, &gui_rect_getTopRelative, 0);
			duk_push_c_function(ctx, &gui_rect_setTopRelative, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "BottomPoints");
			duk_push_c_function(ctx, &gui_rect_getBottomPoints, 0);
			duk_push_c_function(ctx, &gui_rect_setBottomPoints, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_rect");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "BottomRelative");
			duk_push_c_function(ctx, &gui_rect_getBottomRelative, 0);
			duk_push_c_function(ctx, &gui_rect_setBottomRelative, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// gui_button
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "gui_button");
			duk_get_global_string(ctx, "gui_button");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "HoveredColorRGBA");
			duk_push_c_function(ctx, &gui_button_getHoveredColorRGBA, 0);
			duk_push_c_function(ctx, &gui_button_setHoveredColorRGBA, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_button");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "HoveredCursor");
			duk_push_c_function(ctx, &gui_button_getHoveredCursor, 0);
			duk_push_c_function(ctx, &gui_button_setHoveredCursor, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// gui_image
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "gui_image");
			duk_get_global_string(ctx, "gui_image");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Enabled");
			duk_push_c_function(ctx, &gui_image_getEnabled, 0);
			duk_push_c_function(ctx, &gui_image_setEnabled, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_image");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ColorRGBA");
			duk_push_c_function(ctx, &gui_image_getColorRGBA, 0);
			duk_push_c_function(ctx, &gui_image_setColorRGBA, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_image");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Sprite");
			duk_push_c_function(ctx, &gui_image_getSprite, 0);
			duk_push_c_function(ctx, &gui_image_setSprite, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// gui_text
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "gui_text");
			duk_get_global_string(ctx, "gui_text");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "FontSize");
			duk_push_c_function(ctx, &gui_text_getFontSize, 0);
			duk_push_c_function(ctx, &gui_text_setFontSize, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_text");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ColorRGBA");
			duk_push_c_function(ctx, &gui_text_getColorRGBA, 0);
			duk_push_c_function(ctx, &gui_text_setColorRGBA, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_text");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "FontPath");
			duk_push_c_function(ctx, &gui_text_getFontPath, 0);
			duk_push_c_function(ctx, &gui_text_setFontPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_text");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "HAlign");
			duk_push_c_function(ctx, &gui_text_getHAlign, 0);
			duk_push_c_function(ctx, &gui_text_setHAlign, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_text");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "VAlign");
			duk_push_c_function(ctx, &gui_text_getVAlign, 0);
			duk_push_c_function(ctx, &gui_text_setVAlign, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "gui_text");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Text");
			duk_push_c_function(ctx, &gui_text_getText, 0);
			duk_push_c_function(ctx, &gui_text_setText, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// lua_script
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "lua_script");
		}
		// lua_script_inline
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "lua_script_inline");
			duk_get_global_string(ctx, "lua_script_inline");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Code");
			duk_push_c_function(ctx, &lua_script_inline_getCode, 0);
			duk_push_c_function(ctx, &lua_script_inline_setCode, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// navmesh_zone
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "navmesh_zone");
			duk_get_global_string(ctx, "navmesh_zone");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Autoload");
			duk_push_c_function(ctx, &navmesh_zone_getAutoload, 0);
			duk_push_c_function(ctx, &navmesh_zone_setAutoload, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "navmesh_zone");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Detailed");
			duk_push_c_function(ctx, &navmesh_zone_getDetailed, 0);
			duk_push_c_function(ctx, &navmesh_zone_setDetailed, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// navmesh_agent
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "navmesh_agent");
			duk_get_global_string(ctx, "navmesh_agent");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Radius");
			duk_push_c_function(ctx, &navmesh_agent_getRadius, 0);
			duk_push_c_function(ctx, &navmesh_agent_setRadius, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "navmesh_agent");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Height");
			duk_push_c_function(ctx, &navmesh_agent_getHeight, 0);
			duk_push_c_function(ctx, &navmesh_agent_setHeight, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "navmesh_agent");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "MoveEntity");
			duk_push_c_function(ctx, &navmesh_agent_getMoveEntity, 0);
			duk_push_c_function(ctx, &navmesh_agent_setMoveEntity, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "navmesh_agent");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Speed");
			duk_push_c_function(ctx, &navmesh_agent_getSpeed, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// physical_heightfield
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "physical_heightfield");
			duk_get_global_string(ctx, "physical_heightfield");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Source");
			duk_push_c_function(ctx, &physical_heightfield_getSource, 0);
			duk_push_c_function(ctx, &physical_heightfield_setSource, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_heightfield");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "XZScale");
			duk_push_c_function(ctx, &physical_heightfield_getXZScale, 0);
			duk_push_c_function(ctx, &physical_heightfield_setXZScale, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_heightfield");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "YScale");
			duk_push_c_function(ctx, &physical_heightfield_getYScale, 0);
			duk_push_c_function(ctx, &physical_heightfield_setYScale, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_heightfield");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Layer");
			duk_push_c_function(ctx, &physical_heightfield_getLayer, 0);
			duk_push_c_function(ctx, &physical_heightfield_setLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// d6_joint
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "d6_joint");
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "XMotion");
			duk_push_c_function(ctx, &d6_joint_getXMotion, 0);
			duk_push_c_function(ctx, &d6_joint_setXMotion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "YMotion");
			duk_push_c_function(ctx, &d6_joint_getYMotion, 0);
			duk_push_c_function(ctx, &d6_joint_setYMotion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ZMotion");
			duk_push_c_function(ctx, &d6_joint_getZMotion, 0);
			duk_push_c_function(ctx, &d6_joint_setZMotion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Swing1Motion");
			duk_push_c_function(ctx, &d6_joint_getSwing1Motion, 0);
			duk_push_c_function(ctx, &d6_joint_setSwing1Motion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Swing2Motion");
			duk_push_c_function(ctx, &d6_joint_getSwing2Motion, 0);
			duk_push_c_function(ctx, &d6_joint_setSwing2Motion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "TwistMotion");
			duk_push_c_function(ctx, &d6_joint_getTwistMotion, 0);
			duk_push_c_function(ctx, &d6_joint_setTwistMotion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "LinearLimit");
			duk_push_c_function(ctx, &d6_joint_getLinearLimit, 0);
			duk_push_c_function(ctx, &d6_joint_setLinearLimit, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "TwistLimit");
			duk_push_c_function(ctx, &d6_joint_getTwistLimit, 0);
			duk_push_c_function(ctx, &d6_joint_setTwistLimit, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "SwingLimit");
			duk_push_c_function(ctx, &d6_joint_getSwingLimit, 0);
			duk_push_c_function(ctx, &d6_joint_setSwingLimit, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Damping");
			duk_push_c_function(ctx, &d6_joint_getDamping, 0);
			duk_push_c_function(ctx, &d6_joint_setDamping, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Stiffness");
			duk_push_c_function(ctx, &d6_joint_getStiffness, 0);
			duk_push_c_function(ctx, &d6_joint_setStiffness, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Restitution");
			duk_push_c_function(ctx, &d6_joint_getRestitution, 0);
			duk_push_c_function(ctx, &d6_joint_setRestitution, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ConnectedBody");
			duk_push_c_function(ctx, &d6_joint_getConnectedBody, 0);
			duk_push_c_function(ctx, &d6_joint_setConnectedBody, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AxisPosition");
			duk_push_c_function(ctx, &d6_joint_getAxisPosition, 0);
			duk_push_c_function(ctx, &d6_joint_setAxisPosition, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "d6_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AxisDirection");
			duk_push_c_function(ctx, &d6_joint_getAxisDirection, 0);
			duk_push_c_function(ctx, &d6_joint_setAxisDirection, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// distance_joint
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "distance_joint");
			duk_get_global_string(ctx, "distance_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ConnectedBody");
			duk_push_c_function(ctx, &distance_joint_getConnectedBody, 0);
			duk_push_c_function(ctx, &distance_joint_setConnectedBody, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "distance_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AxisPosition");
			duk_push_c_function(ctx, &distance_joint_getAxisPosition, 0);
			duk_push_c_function(ctx, &distance_joint_setAxisPosition, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "distance_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Damping");
			duk_push_c_function(ctx, &distance_joint_getDamping, 0);
			duk_push_c_function(ctx, &distance_joint_setDamping, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "distance_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Stiffness");
			duk_push_c_function(ctx, &distance_joint_getStiffness, 0);
			duk_push_c_function(ctx, &distance_joint_setStiffness, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "distance_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Tolerance");
			duk_push_c_function(ctx, &distance_joint_getTolerance, 0);
			duk_push_c_function(ctx, &distance_joint_setTolerance, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "distance_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Limits");
			duk_push_c_function(ctx, &distance_joint_getLimits, 0);
			duk_push_c_function(ctx, &distance_joint_setLimits, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "distance_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "LinearForce");
			duk_push_c_function(ctx, &distance_joint_getLinearForce, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// hinge_joint
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "hinge_joint");
			duk_get_global_string(ctx, "hinge_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ConnectedBody");
			duk_push_c_function(ctx, &hinge_joint_getConnectedBody, 0);
			duk_push_c_function(ctx, &hinge_joint_setConnectedBody, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "hinge_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AxisPosition");
			duk_push_c_function(ctx, &hinge_joint_getAxisPosition, 0);
			duk_push_c_function(ctx, &hinge_joint_setAxisPosition, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "hinge_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AxisDirection");
			duk_push_c_function(ctx, &hinge_joint_getAxisDirection, 0);
			duk_push_c_function(ctx, &hinge_joint_setAxisDirection, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "hinge_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Damping");
			duk_push_c_function(ctx, &hinge_joint_getDamping, 0);
			duk_push_c_function(ctx, &hinge_joint_setDamping, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "hinge_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Stiffness");
			duk_push_c_function(ctx, &hinge_joint_getStiffness, 0);
			duk_push_c_function(ctx, &hinge_joint_setStiffness, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "hinge_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "UseLimit");
			duk_push_c_function(ctx, &hinge_joint_getUseLimit, 0);
			duk_push_c_function(ctx, &hinge_joint_setUseLimit, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "hinge_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Limit");
			duk_push_c_function(ctx, &hinge_joint_getLimit, 0);
			duk_push_c_function(ctx, &hinge_joint_setLimit, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// spherical_joint
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "spherical_joint");
			duk_get_global_string(ctx, "spherical_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ConnectedBody");
			duk_push_c_function(ctx, &spherical_joint_getConnectedBody, 0);
			duk_push_c_function(ctx, &spherical_joint_setConnectedBody, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "spherical_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AxisPosition");
			duk_push_c_function(ctx, &spherical_joint_getAxisPosition, 0);
			duk_push_c_function(ctx, &spherical_joint_setAxisPosition, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "spherical_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AxisDirection");
			duk_push_c_function(ctx, &spherical_joint_getAxisDirection, 0);
			duk_push_c_function(ctx, &spherical_joint_setAxisDirection, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "spherical_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "UseLimit");
			duk_push_c_function(ctx, &spherical_joint_getUseLimit, 0);
			duk_push_c_function(ctx, &spherical_joint_setUseLimit, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "spherical_joint");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Limit");
			duk_push_c_function(ctx, &spherical_joint_getLimit, 0);
			duk_push_c_function(ctx, &spherical_joint_setLimit, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// physical_controller
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "physical_controller");
			duk_get_global_string(ctx, "physical_controller");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Layer");
			duk_push_c_function(ctx, &physical_controller_getLayer, 0);
			duk_push_c_function(ctx, &physical_controller_setLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_controller");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Radius");
			duk_push_c_function(ctx, &physical_controller_getRadius, 0);
			duk_push_c_function(ctx, &physical_controller_setRadius, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_controller");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Height");
			duk_push_c_function(ctx, &physical_controller_getHeight, 0);
			duk_push_c_function(ctx, &physical_controller_setHeight, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_controller");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "CustomGravity");
			duk_push_c_function(ctx, &physical_controller_getCustomGravity, 0);
			duk_push_c_function(ctx, &physical_controller_setCustomGravity, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_controller");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "CustomGravityAcceleration");
			duk_push_c_function(ctx, &physical_controller_getCustomGravityAcceleration, 0);
			duk_push_c_function(ctx, &physical_controller_setCustomGravityAcceleration, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_controller");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "UseRootMotion");
			duk_push_c_function(ctx, &physical_controller_getUseRootMotion, 0);
			duk_push_c_function(ctx, &physical_controller_setUseRootMotion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// rigid_actor
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "rigid_actor");
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Velocity");
			duk_push_c_function(ctx, &rigid_actor_getVelocity, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Speed");
			duk_push_c_function(ctx, &rigid_actor_getSpeed, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Layer");
			duk_push_c_function(ctx, &rigid_actor_getLayer, 0);
			duk_push_c_function(ctx, &rigid_actor_setLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "DynamicType");
			duk_push_c_function(ctx, &rigid_actor_getDynamicType, 0);
			duk_push_c_function(ctx, &rigid_actor_setDynamicType, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "IsTrigger");
			duk_push_c_function(ctx, &rigid_actor_getIsTrigger, 0);
			duk_push_c_function(ctx, &rigid_actor_setIsTrigger, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Mesh");
			duk_push_c_function(ctx, &rigid_actor_getMesh, 0);
			duk_push_c_function(ctx, &rigid_actor_setMesh, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Material");
			duk_push_c_function(ctx, &rigid_actor_getMaterial, 0);
			duk_push_c_function(ctx, &rigid_actor_setMaterial, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "rigid_actor");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "CCD");
			duk_push_c_function(ctx, &rigid_actor_getCCD, 0);
			duk_push_c_function(ctx, &rigid_actor_setCCD, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// wheel
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "wheel");
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "SpringStrength");
			duk_push_c_function(ctx, &wheel_getSpringStrength, 0);
			duk_push_c_function(ctx, &wheel_setSpringStrength, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "SpringMaxCompression");
			duk_push_c_function(ctx, &wheel_getSpringMaxCompression, 0);
			duk_push_c_function(ctx, &wheel_setSpringMaxCompression, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "SpringMaxDroop");
			duk_push_c_function(ctx, &wheel_getSpringMaxDroop, 0);
			duk_push_c_function(ctx, &wheel_setSpringMaxDroop, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "SpringDamperRate");
			duk_push_c_function(ctx, &wheel_getSpringDamperRate, 0);
			duk_push_c_function(ctx, &wheel_setSpringDamperRate, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Radius");
			duk_push_c_function(ctx, &wheel_getRadius, 0);
			duk_push_c_function(ctx, &wheel_setRadius, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Width");
			duk_push_c_function(ctx, &wheel_getWidth, 0);
			duk_push_c_function(ctx, &wheel_setWidth, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Mass");
			duk_push_c_function(ctx, &wheel_getMass, 0);
			duk_push_c_function(ctx, &wheel_setMass, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "MOI");
			duk_push_c_function(ctx, &wheel_getMOI, 0);
			duk_push_c_function(ctx, &wheel_setMOI, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Slot");
			duk_push_c_function(ctx, &wheel_getSlot, 0);
			duk_push_c_function(ctx, &wheel_setSlot, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "wheel");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "RPM");
			duk_push_c_function(ctx, &wheel_getRPM, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// vehicle
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "vehicle");
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "PeakTorque");
			duk_push_c_function(ctx, &vehicle_getPeakTorque, 0);
			duk_push_c_function(ctx, &vehicle_setPeakTorque, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "MaxRPM");
			duk_push_c_function(ctx, &vehicle_getMaxRPM, 0);
			duk_push_c_function(ctx, &vehicle_setMaxRPM, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "RPM");
			duk_push_c_function(ctx, &vehicle_getRPM, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "CurrentGear");
			duk_push_c_function(ctx, &vehicle_getCurrentGear, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Speed");
			duk_push_c_function(ctx, &vehicle_getSpeed, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Chassis");
			duk_push_c_function(ctx, &vehicle_getChassis, 0);
			duk_push_c_function(ctx, &vehicle_setChassis, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Mass");
			duk_push_c_function(ctx, &vehicle_getMass, 0);
			duk_push_c_function(ctx, &vehicle_setMass, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "MOIMultiplier");
			duk_push_c_function(ctx, &vehicle_getMOIMultiplier, 0);
			duk_push_c_function(ctx, &vehicle_setMOIMultiplier, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "CenterOfMass");
			duk_push_c_function(ctx, &vehicle_getCenterOfMass, 0);
			duk_push_c_function(ctx, &vehicle_setCenterOfMass, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "WheelsLayer");
			duk_push_c_function(ctx, &vehicle_getWheelsLayer, 0);
			duk_push_c_function(ctx, &vehicle_setWheelsLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "vehicle");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ChassisLayer");
			duk_push_c_function(ctx, &vehicle_getChassisLayer, 0);
			duk_push_c_function(ctx, &vehicle_setChassisLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// physical_instanced_cube
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "physical_instanced_cube");
			duk_get_global_string(ctx, "physical_instanced_cube");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "HalfExtents");
			duk_push_c_function(ctx, &physical_instanced_cube_getHalfExtents, 0);
			duk_push_c_function(ctx, &physical_instanced_cube_setHalfExtents, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_instanced_cube");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Layer");
			duk_push_c_function(ctx, &physical_instanced_cube_getLayer, 0);
			duk_push_c_function(ctx, &physical_instanced_cube_setLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// physical_instanced_mesh
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "physical_instanced_mesh");
			duk_get_global_string(ctx, "physical_instanced_mesh");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Layer");
			duk_push_c_function(ctx, &physical_instanced_mesh_getLayer, 0);
			duk_push_c_function(ctx, &physical_instanced_mesh_setLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "physical_instanced_mesh");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "GeomPath");
			duk_push_c_function(ctx, &physical_instanced_mesh_getGeomPath, 0);
			duk_push_c_function(ctx, &physical_instanced_mesh_setGeomPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// camera
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "camera");
		}
		// decal
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "decal");
			duk_get_global_string(ctx, "decal");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "MaterialPath");
			duk_push_c_function(ctx, &decal_getMaterialPath, 0);
			duk_push_c_function(ctx, &decal_setMaterialPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "decal");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "HalfExtents");
			duk_push_c_function(ctx, &decal_getHalfExtents, 0);
			duk_push_c_function(ctx, &decal_setHalfExtents, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// environment
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "environment");
			duk_get_global_string(ctx, "environment");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "CastShadows");
			duk_push_c_function(ctx, &environment_getCastShadows, 0);
			duk_push_c_function(ctx, &environment_setCastShadows, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "environment");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "SkyTexture");
			duk_push_c_function(ctx, &environment_getSkyTexture, 0);
			duk_push_c_function(ctx, &environment_setSkyTexture, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "environment");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "ShadowmapCascades");
			duk_push_c_function(ctx, &environment_getShadowmapCascades, 0);
			duk_push_c_function(ctx, &environment_setShadowmapCascades, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// point_light
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "point_light");
			duk_get_global_string(ctx, "point_light");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Range");
			duk_push_c_function(ctx, &point_light_getRange, 0);
			duk_push_c_function(ctx, &point_light_setRange, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "point_light");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "CastShadows");
			duk_push_c_function(ctx, &point_light_getCastShadows, 0);
			duk_push_c_function(ctx, &point_light_setCastShadows, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "point_light");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Dynamic");
			duk_push_c_function(ctx, &point_light_getDynamic, 0);
			duk_push_c_function(ctx, &point_light_setDynamic, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// reflection_probe
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "reflection_probe");
			duk_get_global_string(ctx, "reflection_probe");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Enabled");
			duk_push_c_function(ctx, &reflection_probe_getEnabled, 0);
			duk_push_c_function(ctx, &reflection_probe_setEnabled, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// environment_probe
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "environment_probe");
			duk_get_global_string(ctx, "environment_probe");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Enabled");
			duk_push_c_function(ctx, &environment_probe_getEnabled, 0);
			duk_push_c_function(ctx, &environment_probe_setEnabled, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// fur
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "fur");
		}
		// bone_attachment
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "bone_attachment");
			duk_get_global_string(ctx, "bone_attachment");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Parent");
			duk_push_c_function(ctx, &bone_attachment_getParent, 0);
			duk_push_c_function(ctx, &bone_attachment_setParent, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "bone_attachment");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Bone");
			duk_push_c_function(ctx, &bone_attachment_getBone, 0);
			duk_push_c_function(ctx, &bone_attachment_setBone, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "bone_attachment");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Position");
			duk_push_c_function(ctx, &bone_attachment_getPosition, 0);
			duk_push_c_function(ctx, &bone_attachment_setPosition, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "bone_attachment");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Rotation");
			duk_push_c_function(ctx, &bone_attachment_getRotation, 0);
			duk_push_c_function(ctx, &bone_attachment_setRotation, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// particle_emitter
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "particle_emitter");
			duk_get_global_string(ctx, "particle_emitter");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Path");
			duk_push_c_function(ctx, &particle_emitter_getPath, 0);
			duk_push_c_function(ctx, &particle_emitter_setPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "particle_emitter");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Autodestroy");
			duk_push_c_function(ctx, &particle_emitter_getAutodestroy, 0);
			duk_push_c_function(ctx, &particle_emitter_setAutodestroy, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// instanced_model
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "instanced_model");
			duk_get_global_string(ctx, "instanced_model");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Path");
			duk_push_c_function(ctx, &instanced_model_getPath, 0);
			duk_push_c_function(ctx, &instanced_model_setPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// model_instance
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "model_instance");
			duk_get_global_string(ctx, "model_instance");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Enabled");
			duk_push_c_function(ctx, &model_instance_getEnabled, 0);
			duk_push_c_function(ctx, &model_instance_setEnabled, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "model_instance");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Path");
			duk_push_c_function(ctx, &model_instance_getPath, 0);
			duk_push_c_function(ctx, &model_instance_setPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// curve_decal
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "curve_decal");
			duk_get_global_string(ctx, "curve_decal");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "MaterialPath");
			duk_push_c_function(ctx, &curve_decal_getMaterialPath, 0);
			duk_push_c_function(ctx, &curve_decal_setMaterialPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "curve_decal");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "HalfExtents");
			duk_push_c_function(ctx, &curve_decal_getHalfExtents, 0);
			duk_push_c_function(ctx, &curve_decal_setHalfExtents, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "curve_decal");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "UVScale");
			duk_push_c_function(ctx, &curve_decal_getUVScale, 0);
			duk_push_c_function(ctx, &curve_decal_setUVScale, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "curve_decal");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "BezierP0");
			duk_push_c_function(ctx, &curve_decal_getBezierP0, 0);
			duk_push_c_function(ctx, &curve_decal_setBezierP0, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "curve_decal");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "BezierP2");
			duk_push_c_function(ctx, &curve_decal_getBezierP2, 0);
			duk_push_c_function(ctx, &curve_decal_setBezierP2, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// terrain
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "terrain");
			duk_get_global_string(ctx, "terrain");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Size");
			duk_push_c_function(ctx, &terrain_getSize, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "terrain");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "MaterialPath");
			duk_push_c_function(ctx, &terrain_getMaterialPath, 0);
			duk_push_c_function(ctx, &terrain_setMaterialPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "terrain");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "XZScale");
			duk_push_c_function(ctx, &terrain_getXZScale, 0);
			duk_push_c_function(ctx, &terrain_setXZScale, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "terrain");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Tesselation");
			duk_push_c_function(ctx, &terrain_getTesselation, 0);
			duk_push_c_function(ctx, &terrain_setTesselation, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "terrain");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "BaseGridResolution");
			duk_push_c_function(ctx, &terrain_getBaseGridResolution, 0);
			duk_push_c_function(ctx, &terrain_setBaseGridResolution, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "terrain");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "YScale");
			duk_push_c_function(ctx, &terrain_getYScale, 0);
			duk_push_c_function(ctx, &terrain_setYScale, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// procedural_geom
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "procedural_geom");
			duk_get_global_string(ctx, "procedural_geom");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Material");
			duk_push_c_function(ctx, &procedural_geom_getMaterial, 0);
			duk_push_c_function(ctx, &procedural_geom_setMaterial, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// jolt_mesh
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "jolt_mesh");
			duk_get_global_string(ctx, "jolt_mesh");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Path");
			duk_push_c_function(ctx, &jolt_mesh_getPath, 0);
			duk_push_c_function(ctx, &jolt_mesh_setPath, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// jolt_sphere
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "jolt_sphere");
			duk_get_global_string(ctx, "jolt_sphere");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Radius");
			duk_push_c_function(ctx, &jolt_sphere_getRadius, 0);
			duk_push_c_function(ctx, &jolt_sphere_setRadius, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// jolt_box
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "jolt_box");
			duk_get_global_string(ctx, "jolt_box");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "HalfExtents");
			duk_push_c_function(ctx, &jolt_box_getHalfExtents, 0);
			duk_push_c_function(ctx, &jolt_box_setHalfExtents, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// jolt_body
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "jolt_body");
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Speed");
			duk_push_c_function(ctx, &jolt_body_getSpeed, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Active");
			duk_push_c_function(ctx, &jolt_body_getActive, 0);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "DescreteMotion");
			duk_push_c_function(ctx, &jolt_body_getDescreteMotion, 0);
			duk_push_c_function(ctx, &jolt_body_setDescreteMotion, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Friction");
			duk_push_c_function(ctx, &jolt_body_getFriction, 0);
			duk_push_c_function(ctx, &jolt_body_setFriction, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Restitution");
			duk_push_c_function(ctx, &jolt_body_getRestitution, 0);
			duk_push_c_function(ctx, &jolt_body_setRestitution, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "LinearDamping");
			duk_push_c_function(ctx, &jolt_body_getLinearDamping, 0);
			duk_push_c_function(ctx, &jolt_body_setLinearDamping, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AngularDamping");
			duk_push_c_function(ctx, &jolt_body_getAngularDamping, 0);
			duk_push_c_function(ctx, &jolt_body_setAngularDamping, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "DynamicType");
			duk_push_c_function(ctx, &jolt_body_getDynamicType, 0);
			duk_push_c_function(ctx, &jolt_body_setDynamicType, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "Layer");
			duk_push_c_function(ctx, &jolt_body_getLayer, 0);
			duk_push_c_function(ctx, &jolt_body_setLayer, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "LinearVelocity");
			duk_push_c_function(ctx, &jolt_body_getLinearVelocity, 0);
			duk_push_c_function(ctx, &jolt_body_setLinearVelocity, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
			duk_get_global_string(ctx, "jolt_body");
			if (duk_get_prop_string(ctx, -1, "prototype") != 1) {
				ASSERT(false);
			}
			duk_push_string(ctx, "AngularVelocity");
			duk_push_c_function(ctx, &jolt_body_getAngularVelocity, 0);
			duk_push_c_function(ctx, &jolt_body_setAngularVelocity, 1);
			duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);
			duk_pop_2(ctx);
			
		}
		// js_script
		{
			duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);
			duk_push_object(ctx); // prototype
			duk_put_prop_string(ctx, -2, "prototype");
			duk_put_global_string(ctx, "js_script");
		}
	}
}
