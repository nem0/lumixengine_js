#include "meta/meta.h"

#define OUT_ENDL "\r\n"
#define L(...) out.add(__VA_ARGS__, OUT_ENDL)

static Enum* getEnum(MetaData& data, Module& m, StringView name) {
	for (Enum& e : data.enums) {
		if (equal(e.name, name)) return &e;
		if (equal(e.full, name)) return &e;
	}
	for (Enum& e : m.enums) {
		if (equal(e.name, name)) return &e;
		if (equal(e.full, name)) return &e;
	}
	return nullptr;
}

void serializeGetter(OutputStream& out, MetaData& data, Module& m, Component& c, Property& p) {
	L("static int ",c.id,"_get",p.name,"(duk_context* ctx) {");
	L("duk_push_this(ctx);");
	L("if (duk_is_null_or_undefined(ctx, -1)) {");
	L("	duk_eval_error(ctx, \"`this` is null or undefined\");");
	L("}");
	L("duk_get_prop_string(ctx, -1, \"c_module\");");
	L("auto* module = JSWrapper::toType<",m.name,"*>(ctx, -1);");
	L("if(!module) duk_eval_error(ctx, \"getting property on invalid object\");");
	L("duk_get_prop_string(ctx, -2, \"c_entity\");");
	L("EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);");
	if (Enum* e = getEnum(data, m, p.type)) {
		L("JSWrapper::push(ctx, (i32)module->",p.getter_name,"(entity));");
	}
	else {
		L("JSWrapper::push(ctx, module->",p.getter_name,"(entity));");
	}
	L("return 1;");
	L("}" OUT_ENDL);
}

void serializerSetter(OutputStream& out, MetaData& data, Module& m, Component& c, Property& p) {
	L("static int ",c.id,"_set",p.name,"(duk_context* ctx) {");
	L("duk_push_this(ctx);");
	L("if (duk_is_null_or_undefined(ctx, -1)) {");
	L("	duk_eval_error(ctx, \"`this` is null or undefined\");");
	L("}");
	L("duk_get_prop_string(ctx, -1, \"c_module\");");
	L("auto* module = JSWrapper::toType<",m.name,"*>(ctx, -1);");
	L("if (!module) duk_eval_error(ctx, \"getting property on invalid object\");");
	L("duk_get_prop_string(ctx, -2, \"c_entity\");");
	L("EntityRef entity = JSWrapper::toType<EntityRef>(ctx, -1);");
	L("duk_pop_2(ctx);");
	if (Enum* e = getEnum(data, m, p.type)) {
		L("auto value = (",e->full,")JSWrapper::checkArg<i32>(ctx, 3);");
	}
	else {
		L("auto value = JSWrapper::checkArg<",p.type,">(ctx, 3);");
	}
	L("ctx, module->",p.setter_name,"(entity, value);");
	L("return 0;");
	L("}" OUT_ENDL);
}

bool isLetter(char c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); }
bool isNumeric(char c) { return c >= '0' && c <= '9'; }
bool isUpperCase(char c) { return c >= 'A' && c <= 'Z'; }
bool isWhitespace(char c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t'; }

static void convertPropertyToJSName(StringView src, Span<char> out) {
	bool to_upper = true;
	char* dest = out.begin;
	const char* src_c = src.begin;
	while (src_c != src.end && dest != out.end - 1) {
		if (isLetter(*src_c)) {
			*dest = to_upper && !isUpperCase(*src_c) ? *src_c - 'a' + 'A' : *src_c;
			to_upper = false;
			++dest;
		} else if (isNumeric(*src_c)) {
			*dest = *src_c;
			++dest;
		} else {
			to_upper = true;
		}
		++src_c;
	}
	*dest = 0;
}

static void metaJS(MetaData& data) {
	OutputStream out;
	L("// Generated by meta_js.cpp" OUT_ENDL);
	
	for (Object& o : data.objects) {
		StringView include_path = makeStringView(o.filename);
		StringView path = find(include_path, "src/");
		if (startsWith(include_path, "plugins/")) {
			L("#include \"../", include_path, "\"");
		}
		else {
			if (startsWith(include_path, "src/")) include_path = withoutPrefix(include_path, 4);
			L("#include \"",include_path,"\"");
		}
	}
	for (Module& m : data.modules) {
		for (StringView include_path : m.includes) {
			L("#include \"",include_path,"\"");
		}
		StringView include_path = makeStringView(m.filename);
		if (startsWith(include_path, "plugins/")) {
			L("#include \"../", include_path, "\"");
		}
		else {
			if (startsWith(include_path, "src/")) include_path = withoutPrefix(include_path, 4);
			L("#include \"",include_path,"\"");
		}
	}
	
	L(OUT_ENDL);
	L("namespace Lumix {");

	for (Module& m : data.modules) {
		for (Component& c : m.components) {
			for (Property& p : c.properties) {
				if (p.is_var) continue; // TODO
				if (isBlob(p)) continue;
				if (p.getter_name.size() > 0) {
					serializeGetter(out, data, m, c, p);
					if (p.setter_name.size() > 0) {
						serializerSetter(out, data, m, c, p);
					}
				}
			}
		}
	}
	L("void registerJSAPI(duk_context* ctx) {");
	for (Module& m : data.modules) {
		for (Component& c : m.components) {
			L("// ",c.id);
			L("{");
			L("duk_push_c_function(ctx, &componentJSConstructor, DUK_VARARGS);");
			L("duk_push_object(ctx); // prototype");
			L("duk_put_prop_string(ctx, -2, \"prototype\");");
			L("duk_put_global_string(ctx, \"",c.id,"\");");

			for (Property& p : c.properties) {
				if (p.is_var) continue; // TODO
				if (isBlob(p)) continue;
				if (p.getter_name.size() == 0) continue;

				char tmp[50];
				// TODO as lua?
				convertPropertyToJSName(p.name, Span(tmp, tmp + sizeof(tmp)));
				L("duk_get_global_string(ctx, \"",c.id,"\");");
				L("if (duk_get_prop_string(ctx, -1, \"prototype\") != 1) {");
				L("	ASSERT(false);");
				L("}");
				L("duk_push_string(ctx, \"",tmp,"\");");
				L("duk_push_c_function(ctx, &",c.id,"_get",p.name,", 0);");
				if (p.setter_name.size() > 0) {
					L("duk_push_c_function(ctx, &",c.id,"_set",p.name,", 1);");
					L("duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_ENUMERABLE);");
				}
				else {
					L("duk_def_prop(ctx, -4, DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_ENUMERABLE);");
				}
				L("duk_pop_2(ctx);");
				L("");
			}
			L("}");
		}
	}
	L("}" OUT_ENDL "}");

	formatCPP(out);
	writeFile("plugins/js/src/js_capi.gen.h", out);
}

META_PLUGIN(metaJS);
